package mcp

import (
	"reflect"

	"github.com/ilxqx/vef-framework-go/encoding"
	"github.com/invopop/jsonschema"
)

// reflector is a pre-configured jsonschema reflector for MCP.
var reflector = &jsonschema.Reflector{
	// Anonymous prevents $id from being generated based on package path.
	Anonymous: true,
	// DoNotReference inlines nested types instead of using $ref.
	DoNotReference: true,
	// RequiredFromJSONSchemaTags uses jsonschema:"required" tag to mark required fields.
	RequiredFromJSONSchemaTags: true,
}

// SchemaFor returns a JSON Schema for the type T.
// This follows the same naming convention as reflect.TypeFor.
//
// The generated schema is suitable for use as MCP Tool.InputSchema or output schema.
//
// Usage:
//
//	type MyInput struct {
//	    Name string `json:"name" jsonschema:"required,description=The name"`
//	    Age  int    `json:"age,omitempty" jsonschema:"minimum=0,maximum=150"`
//	}
//
//	schema := mcp.SchemaFor[MyInput]()
//
// Supported jsonschema tags (use `jsonschema:"tag1,tag2=value"`):
//
// Generic (all types):
//   - required: marks the field as required
//   - title=xxx: field title
//   - description=xxx: field description
//   - default=xxx: default value
//   - example=xxx: example value (can be repeated)
//   - enum=A,enum=B: enumeration values
//   - oneof_type=string;integer: field can be one of multiple types
//   - anyof_type=string;integer: field can be any of multiple types
//
// String type:
//   - minLength=N: minimum string length
//   - maxLength=N: maximum string length
//   - pattern=xxx: regex pattern
//   - format=xxx: format hint (email, uri, uuid, date-time, date, time, ipv4, ipv6, etc.)
//   - readOnly=true: field is read-only
//   - writeOnly=true: field is write-only
//
// Number/Integer type:
//   - minimum=N: minimum value
//   - maximum=N: maximum value
//   - exclusiveMinimum=N: exclusive minimum value
//   - exclusiveMaximum=N: exclusive maximum value
//   - multipleOf=N: value must be multiple of N
//
// Array type:
//   - minItems=N: minimum array length
//   - maxItems=N: maximum array length
//   - uniqueItems=true: items must be unique
//
// Additional tags:
//   - jsonschema_description:"xxx": standalone description tag
//   - jsonschema_extras:"a=b,c=d": add custom schema properties
func SchemaFor[T any]() map[string]any {
	return schemaFromType(reflect.TypeFor[T]())
}

// SchemaOf returns a JSON Schema for the type of v.
// This follows the same naming convention as reflect.TypeOf.
//
// If v is nil, SchemaOf returns nil.
func SchemaOf(v any) map[string]any {
	if v == nil {
		return nil
	}
	return schemaFromType(reflect.TypeOf(v))
}

// MustSchemaFor is like SchemaFor but panics on error.
func MustSchemaFor[T any]() map[string]any {
	result := SchemaFor[T]()
	if result == nil {
		panic("mcp: failed to generate schema")
	}
	return result
}

// MustSchemaOf is like SchemaOf but panics on error.
func MustSchemaOf(v any) map[string]any {
	result := SchemaOf(v)
	if result == nil {
		panic("mcp: failed to generate schema")
	}
	return result
}

// schemaFromType generates JSON Schema from a reflect.Type.
func schemaFromType(t reflect.Type) map[string]any {
	schema := reflector.ReflectFromType(t)

	json, err := encoding.ToJson(schema)
	if err != nil {
		return nil
	}

	result, err := encoding.FromJson[map[string]any](json)
	if err != nil {
		return nil
	}

	// $schema is always generated by the library, must be removed for MCP
	delete(*result, "$schema")

	return *result
}
